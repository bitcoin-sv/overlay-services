/* eslint-env jest */
import { Confederacy } from '../src/Confederacy'
import { AdmissableOutputs, TopicManager } from '../src/Interfaces/TopicManager'
import { LookupService } from '../src/Interfaces/LookupService'
import { Output } from '../src/Models/Output'
import { StorageEngine } from '../src/Interfaces/StorageEngine'
import { ChaintracksServiceClient } from '@cwi/chaintracks-core'
import { SpvVerifier } from '@cwi/chaintracks-spv'
import { TransactionParser } from '../src/utils/TransactionParser'
import { Transaction } from '../src/Models/Transaction'
import assert from 'assert'

const BSV_NETWORK = 'mainnet'

jest.mock('@cwi/chaintracks-spv')
const ccPort = BSV_NETWORK === 'mainnet' ? 8084 : 8083
const chaintracks = new ChaintracksServiceClient(BSV_NETWORK === 'mainnet' ? 'main' : 'test', `http://npm-registry.babbage.systems:${ccPort}`)
const verifier = new SpvVerifier(chaintracks)

const mockDB = [
    new Output('txid1', 0, '016a', 1000, '00000000')
]

// Example implementations
// TODO: Move to test helper files
class HelloTopicManager implements TopicManager {
    identifyAdmissibleOutputs({ previousUTXOs, parsedTransaction }: { previousUTXOs: Output[]; parsedTransaction: Transaction }): number[] | AdmissableOutputs {
        throw new Error('Method not implemented.')
    }
}
class HelloLookupService implements LookupService {
    outputAdded(params: { txid: string; outputIndex: number; outputScript: Buffer; topic: string }): Promise<void> {
        throw new Error('Method not implemented.')
    }
    outputSpent(params: { txid: string; outputIndex: number; topic: string }): Promise<void> {
        throw new Error('Method not implemented.')
    }
    lookup(query: { query: object }): Promise<LookupResultsArray> {
        throw new Error('Method not implemented.')
    }
}

// Is this the best way to mock a storage engine?
class HelloStorageEngine implements StorageEngine {
    addUTXO(utxo: Output): Promise<number> {
        throw new Error('Method not implemented.')
    }
    deleteUTXOById(id: number): Promise<void> {
        throw new Error('Method not implemented.')
    }
    updateConsumedBy(id: number, consumedBy: string): Promise<void> {
        throw new Error('Method not implemented.')
    }
    findUTXO(txid: string, outputIndex: number, topic?: string | undefined): Promise<Output[]> {
        return Promise.resolve(mockDB.filter(x => x.txid === txid && x.outputIndex === outputIndex))
    }
    findUTXOById(id: number): Promise<Output[]> {
        return Promise.resolve([ new Output(
            'someTxid',
            0,
            '1a6',
            'hello',
             1000,
             'rawTx',
             false,
             undefined,
             undefined,
             undefined,
             '[0]',
             undefined,
             1
      )])
    }
    deleteUTXO(txid: string, outputIndex: number, topic: string): Promise<void> {
        throw new Error('Method not implemented.')
    }
    markUTXOAsSpent(txid: string, outputIndex: number, topic: string): Promise<void> {
        throw new Error('Method not implemented.')
    }
    insertAppliedTransaction(txid: string, topic: string): Promise<void> {
        throw new Error('Method not implemented.')
    }
    findAppliedTransaction(txid: string, topic: string): Promise<object> {
        throw new Error('Method not implemented.')
    }
}

describe("Confederacy.test", () => {
    const confederacy = new Confederacy(
        { "Hello": new HelloTopicManager() },
        { "Hello": new HelloLookupService() },
        new HelloStorageEngine(),
        verifier,
        new TransactionParser(),
        undefined
    )   

    beforeAll(async () => {  
    })

    beforeEach(async () => {
    })

    test("UTXO submission", async () => {
        // debugger
        // const result = await confederacy.submit(
        //     'somerawTx',
        //     {},
        //     {}, // How to mock mapi response?
        //     undefined, ['hello']
        // )
    }, 300000)

    test("UTXO lookup", async () => {
        // Test that the standard UTXO lookup is working correctly
        const result = await confederacy.lookup('Hello', {id: 2})
        assert.deepEqual(result, 
            [ new Output(
                'someTxid2',
                0,
                '1a6',
                'hello',
                 1000,
                 'rawTx',
                 false,
                 undefined,
                 undefined,
                 undefined,
                 '[1]',
                 undefined,
                 2
          )])
    }, 300000)

    test("UTXO lookup with history", async () => {
        // Test that the standard UTXO lookup is working correctly
        const result = await confederacy.lookup('Hello', {id: 2}, 1)
        assert.deepEqual(result, 
            [ new Output(
              'someTxid2',
              0,
              '1a6',
              'hello',
               1000,
               'rawTx',
               false,
               undefined,
               undefined,
               undefined,
               '[1]',
               [new Output(
                'someTxid',
                0,
                '1a6',
                'hello',
                 1000,
                 'rawTx',
                 false,
                 undefined,
                 undefined,
                 undefined,
                 '[0]',
                 undefined,
                 1
          )],
               2
        )])
    }, 300000)

})